# üó∫Ô∏è Adress-Normalisierung vor Dataset-Erstellung

**Datum:** 2025-10-18  
**Zweck:** Dokumentation des kompletten Adress-Normalisierungs-Ablaufs via Google Geocoding API

---

## üìä √úbersicht: Von User-Eingabe bis normalisierte Adresse

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. USER EINGABE (Frontend)                                          ‚îÇ
‚îÇ    street: "Schnellweider str", number: "12A", postal: "41462"     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. FRONTEND VALIDIERUNG (scanner.tsx / ResultsDisplay.tsx)         ‚îÇ
‚îÇ    ‚úÖ Pr√ºfung: street && number && postal vorhanden                ‚îÇ
‚îÇ    ‚ùå Abbruch wenn fehlt: Toast-Meldung OHNE Backend-Call          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. API REQUEST                                                       ‚îÇ
‚îÇ    POST /api/address-datasets                                        ‚îÇ
‚îÇ    Body: { address: {...}, editableResidents: [...] }              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. BACKEND VALIDIERUNG (addressDatasets.ts)                        ‚îÇ
‚îÇ    ‚úÖ Pr√ºfung mit .trim(): street, number, postal                  ‚îÇ
‚îÇ    ‚ùå Abbruch wenn fehlt: 400 Response mit missingFields[]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5. NORMALISIERUNG (googleSheets.normalizeAddress)                  ‚îÇ
‚îÇ    üìç Google Geocoding API Aufruf                                   ‚îÇ
‚îÇ    üîç Validierung der Adresse                                       ‚îÇ
‚îÇ    üìã Extraktion standardisierter Komponenten                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 6. DUPLIKATS-CHECK (30 Tage)                                        ‚îÇ
‚îÇ    üîç Suche nach existierendem Dataset mit flexibler Hausnummer     ‚îÇ
‚îÇ    ‚ùå Abbruch wenn gefunden: 409 Response                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 7. RACE CONDITION CHECK (Lock-Map)                                  ‚îÇ
‚îÇ    üîí Pr√ºfe ob Dataset bereits erstellt wird                        ‚îÇ
‚îÇ    ‚ùå Abbruch wenn locked: 409 Response                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 8. DATASET ERSTELLEN                                                 ‚îÇ
‚îÇ    ‚úÖ Mit normalisierten Adressen-Komponenten                       ‚îÇ
‚îÇ    üóÑÔ∏è Speichern in Google Sheets                                   ‚îÇ
‚îÇ    üîì Lock entfernen nach Completion                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üîç Schritt 5 im Detail: normalizeAddress()

### Eingabe-Parameter:
```typescript
normalizeAddress(
  street: "Schnellweider str",  // User-Eingabe (Tippfehler, Kleinschreibung)
  number: "12A",                // Hausnummer (wird IMMER beibehalten!)
  city: "Neuss",                // Optional
  postal: "41462",              // Pflichtfeld
  username: "damian"            // F√ºr Rate-Limiting
)
```

---

### 5.1 Triple-Check Validierung

```typescript
// SCHRITT 1: Pflichtfeld-Pr√ºfung
if (!street || !street.trim()) {
  throw new Error('Stra√üe muss angegeben werden');
}
if (!number || !number.trim()) {
  throw new Error('Hausnummer muss angegeben werden');
}
if (!postal || !postal.trim()) {
  throw new Error('Postleitzahl muss angegeben werden');
}
```

**Resultat:** ‚úÖ Alle Pflichtfelder vorhanden

---

### 5.2 Google API Key Check

```typescript
const apiKey = process.env.GOOGLE_GEOCODING_API_KEY;
if (!apiKey) {
  console.warn('Google Geocoding API key not configured');
  return null; // ‚ùå Normalisierung nicht m√∂glich
}
```

**Resultat:** ‚úÖ API-Key vorhanden

---

### 5.3 Rate-Limiting Check

```typescript
if (username) {
  const rateLimitCheck = checkRateLimit(username, 'geocoding');
  if (rateLimitCheck.limited) {
    throw new Error(rateLimitCheck.message);
  }
  incrementRateLimit(username, 'geocoding');
}
```

**Zweck:** Verhindert API-Missbrauch (zu viele Requests pro User)

**Resultat:** ‚úÖ Limit nicht erreicht ‚Üí Counter erh√∂ht

---

### 5.4 Address String Construction

```typescript
const addressString = `${street} ${number}, ${postal} ${city || ''}, Deutschland`.trim();
// Resultat: "Schnellweider str 12A, 41462 Neuss, Deutschland"
```

**Wichtig:** 
- Hausnummer (`number`) wird MIT √ºbergeben an Google
- Google korrigiert Rechtschreibfehler im Stra√üennamen
- Google findet √§hnliche Adressen (z.B. "str" ‚Üí "Stra√üe")

---

### 5.5 Google Geocoding API Request

```typescript
const url = `https://maps.googleapis.com/maps/api/geocode/json
  ?address=${encodeURIComponent(addressString)}
  &key=${apiKey}
  &language=de`;

const response = await fetch(url);
const data = await response.json();
```

**Beispiel-Response:**
```json
{
  "status": "OK",
  "results": [
    {
      "formatted_address": "Schnellweider Stra√üe 12, 41462 Neuss",
      "address_components": [
        {
          "long_name": "12",
          "short_name": "12",
          "types": ["street_number"]
        },
        {
          "long_name": "Schnellweider Stra√üe",
          "short_name": "Schnellweider Str.",
          "types": ["route"]
        },
        {
          "long_name": "Neuss",
          "short_name": "Neuss",
          "types": ["locality", "political"]
        },
        {
          "long_name": "41462",
          "short_name": "41462",
          "types": ["postal_code"]
        }
      ],
      "geometry": {
        "location": {
          "lat": 51.214198,
          "lng": 6.678189
        },
        "location_type": "ROOFTOP"  // ‚úÖ H√∂chste Pr√§zision!
      }
    }
  ]
}
```

---

### 5.6 Validation Logic (Multi-Level)

#### Level 1: Component-Checks
```typescript
const hasRoute = addressComponents.some(component => 
  component.types.includes('route')  // Stra√üenname vorhanden?
);

const hasStreetNumber = addressComponents.some(component => 
  component.types.includes('street_number')  // Hausnummer vorhanden?
);

const locationType = result.geometry?.location_type;
// M√∂gliche Werte:
// - ROOFTOP: Exakte Adresse (h√∂chste Pr√§zision)
// - RANGE_INTERPOLATED: Interpoliert zwischen Hausnummern
// - GEOMETRIC_CENTER: Zentrum eines Bereichs (niedrigere Pr√§zision)
// - APPROXIMATE: Ungef√§hre Position (niedrigste Pr√§zision)
```

#### Level 2: High Precision Check
```typescript
if (locationType === 'ROOFTOP' || locationType === 'RANGE_INTERPOLATED') {
  console.log('[normalizeAddress] ‚úÖ Accepted: High precision location type');
  return extractAddressComponents(result, number);
}
```

**Resultat:** ‚úÖ `ROOFTOP` ‚Üí Adresse wird akzeptiert!

#### Level 3: Fallback-Validierungen (bei niedrigerer Pr√§zision)
```typescript
// Fallback 1: Formatted Address enth√§lt Stra√üenname + PLZ + hat Route-Component
if (hasRoute && 
    formattedLower.includes(streetLower) && 
    formattedLower.includes(postalStr)) {
  return extractAddressComponents(result, number);
}

// Fallback 2: Route-Component + PLZ stimmt
if (hasRoute && formattedLower.includes(postalStr)) {
  return extractAddressComponents(result, number);
}

// Fallback 3: Nur PLZ stimmt (Last Resort)
if (formattedLower.includes(postalStr)) {
  return extractAddressComponents(result, number);
}

// REJECT: Keine Validierung m√∂glich
return null;
```

**Zweck:** Auch Adressen mit ungew√∂hnlichen Namen akzeptieren (z.B. "Neusser Weyhe")

---

### 5.7 Address Component Extraction

```typescript
function extractAddressComponents(
  result: any, 
  userHouseNumber: string  // ‚ö†Ô∏è WICHTIG: User-Hausnummer wird beibehalten!
): NormalizedAddress {
  const addressComponents = result.address_components;
  const formattedAddress = result.formatted_address;
  
  let street = '';
  let city = '';
  let postal = '';
  
  // Iteriere durch alle address_components
  for (const component of addressComponents) {
    const types = component.types;
    
    if (types.includes('route')) {
      street = component.long_name;  // "Schnellweider Stra√üe"
    } else if (types.includes('locality')) {
      city = component.long_name;    // "Neuss"
    } else if (types.includes('postal_code')) {
      postal = component.long_name;  // "41462"
    }
  }
  
  return {
    formattedAddress,                // "Schnellweider Stra√üe 12, 41462 Neuss"
    street,                          // "Schnellweider Stra√üe" ‚úÖ KORRIGIERT!
    number: userHouseNumber,         // "12A" ‚ö†Ô∏è User-Eingabe beibehalten!
    city,                            // "Neuss"
    postal,                          // "41462"
  };
}
```

**Wichtig:**
- ‚úÖ **Stra√üenname** wird von Google korrigiert (Rechtschreibung, Abk√ºrzungen)
- ‚ö†Ô∏è **Hausnummer** wird NICHT √ºberschrieben (User-Eingabe bleibt!)
- ‚úÖ **Postleitzahl** wird von Google validiert
- ‚úÖ **Stadt** wird von Google standardisiert

---

### 5.8 Return Value

```typescript
// Normalisiertes Objekt:
{
  formattedAddress: "Schnellweider Stra√üe 12, 41462 Neuss",
  street: "Schnellweider Stra√üe",    // ‚úÖ Korrigiert von "Schnellweider str"
  number: "12A",                     // ‚ö†Ô∏è User-Eingabe beibehalten (nicht "12")
  city: "Neuss",
  postal: "41462"
}
```

---

## üéØ Warum wird die Hausnummer NICHT von Google √ºbernommen?

### Problem: Google kennt nicht alle Hausnummern-Suffixe

**Beispiel:**
- User gibt ein: `"Schnellweider Stra√üe 12A"`
- Google kennt nur: `12`, `14`, `16`, ... (ohne Suffixe)
- Google w√ºrde zur√ºckgeben: `street_number: "12"` (OHNE "A")

**L√∂sung:**
```typescript
number: userHouseNumber  // Behalte "12A" vom User!
```

**Vorteil:**
- User kann spezifische Hausnummern-Varianten erfassen (12A, 12B, 12-14, etc.)
- Stra√üenname wird trotzdem von Google korrigiert
- Postleitzahl wird von Google validiert

---

## ‚úÖ Was wird durch Normalisierung erreicht?

| Aspekt | Vorher (User-Eingabe) | Nachher (Normalisiert) |
|--------|----------------------|------------------------|
| **Stra√üenname** | "Schnellweider str" (Tippfehler) | "Schnellweider Stra√üe" ‚úÖ |
| **Gro√ü-/Kleinschreibung** | "schnellweider STR" | "Schnellweider Stra√üe" ‚úÖ |
| **Abk√ºrzungen** | "Schnellweider Str." | "Schnellweider Stra√üe" ‚úÖ |
| **Hausnummer** | "12A" | "12A" ‚ö†Ô∏è BLEIBT! |
| **Postleitzahl** | "41462" | "41462" ‚úÖ VALIDIERT |
| **Stadt** | "neuss" | "Neuss" ‚úÖ |
| **Existenz** | ‚ùì Unbekannt | ‚úÖ VON GOOGLE BEST√ÑTIGT |

---

## üö´ Wann wird eine Adresse abgelehnt?

### Fall 1: Google findet die Adresse nicht
```json
{
  "status": "ZERO_RESULTS"
}
```
**Resultat:** `normalizeAddress()` gibt `null` zur√ºck

---

### Fall 2: Niedrige Pr√§zision + Stra√üenname stimmt nicht √ºberein
```json
{
  "geometry": {
    "location_type": "APPROXIMATE"  // Nur ungef√§hrer Bereich
  },
  "formatted_address": "41462 Neuss"  // Kein Stra√üenname!
}
```
**Resultat:** Fallback-Checks schlagen fehl ‚Üí `null`

---

### Fall 3: Postleitzahl stimmt nicht
```typescript
const postalStr = "41462";
const formattedLower = "schnellweider stra√üe 12, 41460 neuss";  // ‚ùå Falsche PLZ!

if (!formattedLower.includes(postalStr)) {
  return null;  // Adresse wird abgelehnt
}
```

---

## üîí Sicherheit: Was passiert nach der Normalisierung?

### Schritt 6: Duplikats-Check (30 Tage)
```typescript
const existingDataset = await addressDatasetService.getRecentDatasetByAddress(
  normalized.formattedAddress,  // "Schnellweider Stra√üe 12, 41462 Neuss"
  normalized.number,            // "12A"
  30                            // Tage
);

if (existingDataset && existingDataset.isEditable) {
  return res.status(409).json({
    error: 'Dataset already exists',
    message: 'Datensatz existiert bereits'
  });
}
```

**Zweck:** Verhindert doppelte Datens√§tze f√ºr dieselbe Adresse innerhalb 30 Tagen

---

### Schritt 7: Lock-Map (Race Condition Prevention)
```typescript
const lockKey = `${normalized.formattedAddress}:${username}`;

if (creationLocks.has(lockKey)) {
  return res.status(409).json({
    error: 'Dataset creation already in progress',
    message: 'Datensatz wird bereits erstellt'
  });
}

// Lock setzen f√ºr 10 Sekunden
creationLocks.set(lockKey, { timestamp: Date.now() });
```

**Zweck:** Verhindert parallele Dataset-Erstellung f√ºr dieselbe Adresse

---

### Schritt 8: Dataset-Erstellung
```typescript
const dataset = await addressDatasetService.createAddressDataset({
  normalizedAddress: normalized.formattedAddress,  // ‚úÖ Vollst√§ndige Adresse
  street: normalized.street,                       // ‚úÖ Korrigierter Stra√üenname
  houseNumber: normalized.number,                  // ‚ö†Ô∏è User-Hausnummer
  city: normalized.city,                           // ‚úÖ Standardisierte Stadt
  postalCode: normalized.postal,                   // ‚úÖ Validierte PLZ
  // ... weitere Felder
});

// Lock entfernen nach Success/Failure
creationLocks.delete(lockKey);
```

---

## üìä Beispiel: Kompletter Ablauf

### User-Eingabe:
```typescript
{
  street: "schnellweider str",
  number: "12a",
  postal: "41462",
  city: "neuss"
}
```

### Nach Frontend-Validierung:
‚úÖ Alle Pflichtfelder vorhanden ‚Üí Request gesendet

### Nach Backend-Validierung:
‚úÖ `.trim()` Checks erfolgreich ‚Üí Normalisierung starten

### Google Geocoding API Response:
```json
{
  "status": "OK",
  "results": [{
    "formatted_address": "Schnellweider Stra√üe 12, 41462 Neuss",
    "geometry": { "location_type": "ROOFTOP" },
    "address_components": [
      { "long_name": "Schnellweider Stra√üe", "types": ["route"] },
      { "long_name": "Neuss", "types": ["locality"] },
      { "long_name": "41462", "types": ["postal_code"] }
    ]
  }]
}
```

### Normalisiertes Objekt:
```typescript
{
  formattedAddress: "Schnellweider Stra√üe 12, 41462 Neuss",
  street: "Schnellweider Stra√üe",  // ‚úÖ Korrigiert
  number: "12a",                   // ‚ö†Ô∏è User-Eingabe beibehalten
  city: "Neuss",                   // ‚úÖ Standardisiert
  postal: "41462"                  // ‚úÖ Validiert
}
```

### Duplikats-Check:
‚úÖ Kein existierendes Dataset gefunden

### Lock-Check:
‚úÖ Kein Lock vorhanden ‚Üí Lock erstellen

### Dataset erstellt:
```typescript
{
  id: "abc123",
  normalizedAddress: "Schnellweider Stra√üe 12, 41462 Neuss",
  street: "Schnellweider Stra√üe",
  houseNumber: "12a",
  postalCode: "41462",
  city: "Neuss",
  createdBy: "damian",
  createdAt: "2025-10-18T10:30:00Z"
}
```

### Lock entfernt:
‚úÖ `creationLocks.delete("Schnellweider Stra√üe 12, 41462 Neuss:damian")`

---

## üéì Zusammenfassung

### Was macht die Normalisierung?
1. ‚úÖ **Validiert** dass die Adresse existiert (Google kennt sie)
2. ‚úÖ **Korrigiert** Tippfehler im Stra√üennamen
3. ‚úÖ **Standardisiert** Gro√ü-/Kleinschreibung und Abk√ºrzungen
4. ‚úÖ **Verifiziert** die Postleitzahl
5. ‚ö†Ô∏è **Beh√§lt** die User-Hausnummer (wichtig f√ºr Suffixe wie "12A")

### Warum ist das wichtig?
- üîç **Duplikats-Erkennung:** Verhindert mehrfache Datens√§tze f√ºr dieselbe Adresse
- üìä **Konsistenz:** Alle Datens√§tze verwenden dieselbe Schreibweise
- ‚úÖ **Validierung:** Nur existierende Adressen werden akzeptiert
- üîí **Sicherheit:** Multi-Layer Validierung verhindert unvollst√§ndige Daten

### Was passiert NACH der Normalisierung?
1. üîç Duplikats-Check (30 Tage)
2. üîí Race Condition Check (Lock-Map)
3. ‚úÖ Dataset-Erstellung mit normalisierten Daten
4. üîì Lock-Cleanup
